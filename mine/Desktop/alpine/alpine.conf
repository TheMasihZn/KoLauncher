pre-start script
	echo "Log from $(date)" > /mnt/us/alpine.log
	exec >>/mnt/us/alpine.log 2>&1
	echo "# Alpine ::: pre-start script"

	echo "Starting alpine linux"
	mkdir -p /tmp/alpine
	mount -o loop,noatime -t ext3 /mnt/base-us/alpine.ext3 /tmp/alpine
	mount -o bind /dev /tmp/alpine/dev
	mount -o bind /dev/pts /tmp/alpine/dev/pts
	mount -o bind /proc /tmp/alpine/proc
	mount -o bind /sys /tmp/alpine/sys
	mount -o bind /var/run/dbus/ /tmp/alpine/run/dbus/
	cp /etc/hosts /tmp/alpine/etc/hosts
	chmod a+w /dev/shm
end script


script
    exec >>/mnt/us/alpine.log 2>&1
    echo "# Alpine ::: script"

    # Configurable long-press threshold in seconds (default: 2)
    ALPINE_LONGPRESS_SECONDS=${ALPINE_LONGPRESS_SECONDS:-2}

    # Background watcher: long-press Kindle power button to force-exit Alpine
    power_watch() {
        echo "[power_watch] started; long-press >= ${ALPINE_LONGPRESS_SECONDS}s to exit Alpine"
        while true; do
            # Wait for press event
            if lipc-wait-event -s 0 com.lab126.powerd powerButtonPressed >/dev/null 2>&1; then
                t1=$(date +%s)
                # Wait for release, with a sane upper bound so we can re-evaluate if needed
                lipc-wait-event -s 15 com.lab126.powerd powerButtonReleased >/dev/null 2>&1 || true
                t2=$(date +%s)
                dur=$((t2 - t1))
                if [ "$dur" -ge "$ALPINE_LONGPRESS_SECONDS" ]; then
                    echo "[power_watch] Long press detected (${dur}s) -> stopping alpine"
                    # Trigger job stop; post-stop will take care of cleanup and GUI restore
                    stop alpine || true
                    break
                else
                    echo "[power_watch] Short press (${dur}s) ignored"
                fi
            else
                # If no press event is received (unexpected), loop again
                sleep 1
            fi
        done
        echo "[power_watch] exiting"
    }

    # Start watcher in background; keep PID to allow Upstart to reap it on stop
    power_watch &
    PW_PID=$!

    sleep 1
    stop lab126_gui

    su -c "chroot /tmp/alpine /startgui.sh"

    kill $(pgrep Xephyr)
    kill -9 $(lsof -t /var/tmp/alpine/)

    # Ensure watcher exits once we return here (if not already stopped)
    if [ -n "$PW_PID" ] && kill -0 "$PW_PID" 2>/dev/null; then
        echo "[power_watch] stopping (cleanup)"
        kill "$PW_PID" 2>/dev/null || true
    fi
end script


post-stop script
	exec >>/mnt/us/alpine.log 2>&1
	echo "# Alpine ::: post-stop script"

	echo "Unmounting Alpine rootfs"
	LOOPDEV="$(mount | grep loop | grep /tmp/alpine | cut -d" " -f1)"
	umount /tmp/alpine/run/dbus/
	umount /tmp/alpine/sys
	sleep 1
	umount /tmp/alpine/proc
	umount /tmp/alpine/dev/pts
	umount /tmp/alpine/dev
	# Sync beforehand so umount doesn't fail due to the device being busy still
	sync
	umount /tmp/alpine || true
	# Sometimes it fails still and only works by trying again
	while [ "$(mount | grep /tmp/alpine)" ]
	do
		echo "Alpine is still mounted, trying again shortly.."
		sleep 3
		umount /tmp/alpine || true
	done
	echo "Alpine unmounted"
	echo "Disassociating loop device >>$LOOPDEV<<"
	losetup -d $LOOPDEV
	echo "All done, starting kindle's gui."

	start lab126_gui
end script
